---
title: "R Tutorial - Baby Name Data"
author: "Jon Wheeler"
date: "2022-11-02"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Getting to Know R and RStudio

Let's set up a workspace. There are a few different ways of doing this, and
different operating systems may behave differently in terms of navigating
the file system, application permissions, etc. For these reasons, we will
use RStudio to create the project working directory.

1. Launch RStudio from your operating system's application menu.
1. The context of the application - the directory it opens into - is most
likely your home directory.
1. Use the *New Project* command (under the *File* menu) to create a
new project. Alternatively, click on the project icon in the top right of the
application window and select *New Project...*.
1. Select *New Directory* and from the available options. 
1. Select *New Project* from the list of project types.
1. Give the project directory a name - try *cc-R-RStudio* - and click the
*Browse* button to select the location in your file system where the project
will be stored. We recommend storing it in whichever directory you generally
prefer to work in (Desktop, Documents, Home, etc.).
1. When ready, select the button to *Create Project*.
1. Using the *New Folder* button in RStudio's **Files** pane, create a
folder named 'data'.

### The Console

R is an interpreted language. Code does not have to be compiled in order to 
run - instead we use an interpreter (standalone R or the console in RStudio) 
to execute code interactively.

We can demonstrate this by using the console as a calculator.

```{r intro_console}
12 + 12
12 * 12
12 ** 2
144 - 12
144 / 12
```
The console will also echo strings or simple numeric values. 

```{r console_echo}
12
'twelve'
'Greetings from Earth!'
```
Note that strings need to be enclosed in quotes. Notice what happens when we
try to execute the following:

```{r str_error, eval=FALSE}
twelve
```
The term *object* in R is generally synonymous with *variable*. The
error message is telling us there is no object or variable named 'twelve' in
the current environment.

Standard convention in R is to use the term *object* for stored values, data
structures, etc. This is to prevent confusion with the term *variable* as it
is understood in statistics.

#### Exercise: Please Excuse My Dear Aunt Sally

Something to keep in mind as you develop calculations is that mathematical
operations in R follow the standard order of operation (PEMDAS).

What will be the result of the following command? Test your answer by running
the command in the console.

How can we change the command to get a result of 56?

```{r exercise_1}
10 - 3 * 8
```

### Objects

We assign values to objects in R using the *<-* operator. The keyboard shortcut
for this is **ALT -**. 

```{r assignment}
exponent = 2
gross <- 12 ** exponent
gross_squared <- gross ** exponent
```

Objects can also have string values.

```{r str_assignment}
pet <- 'gecko'
```

We can check the data type of an object using the ```class()``` function. We
will look more closely at data types later.

```{r types}
class(exponent)
class(pet)
```

### The Environment Tab

When we previously executed mathematical operations, the output was printed
to the console. Notice that when we assign values to objects, the value of the
object is not printed to the console but is instead displayed in RStudio's
**Environment** tab.

As we develop workflows, it can be helpful to monitor changes to object values.
This is useful especially when we update the values of objects in place.

```{r update_inplace}
my_age <- 18
my_age <- my_age + 1 # Happy birthday!
my_age <- my_age - 40 # This might not be valid.
```

The **Environment** tab provides information about different types of objects
and data structures.

### The Script Pane

So far we have been working in the console, which is great for testing
commands, installing packages, getting help, and other things you may only
want to try out or which don't belong in a script.

Often however, we will do most of our work by running scripts. That's one of
the advantages of using R - scripts allow us to build scalable, reproducible
workflows.

For the remainder of this tutorial, we are mainly going to use an R script 
rather than the console.

#### Exercise: Sanity check.

Let's make sure our working directory is defined so that we can all use the
same example code and paths to read data.

The following command will output the path from the root of your filesystem
to the working directory. Everyone's path will be different, but all of our
paths should end with the name we gave our project folders when we created
a new project, earlier.

If your path ends with something unexpected, please let us know.

```{r wd_check}
# Get working directory
getwd()
```

#### Exercise: History Repeats Itself

Our first script is going to demonstrate some time-saving features of RStudio.
In particular, once we have tested some code in the console, the **History** tab
gives us a way to automatically copy it to a script.

1. Use the green "plus" icon to create a new file. Alternatively, use the
menu commands: File -> New File -> R Script. You can also use the keyboard
shortcut *CTL+SHIFT+N*.
2. In the console, create an object ```distance_k``` and assign it a value.
3. Still in the console, create a second object, ```k_m_ratio``` and assign it
the value 0.62.
4. Create a third object, ```distance_m``` and define it as the product of
```distance_k``` x ```k_m_ratio```.
5. Enter the object name, ```distance_m``` to see the value of the object.

Note that we can use code completion to reduce the amount of typing.

We have working code to convert distances in kilometers to miles, but reusing
it as-is is cumbersome. Instead, we add the code to our new script file and
convert arbitrary distances by changing the value of ```distance_k``` and
running the script.

1. Select the open script tab in the script pane.
2. Select the **History** tab in the top right pane.
3. Scroll down as needed to our conversion code.
4. Highlight a line of code and select **To Source** to copy the code to our
script file. Do this for each line of code we want to reuse.
5. **IMPORTANT!** Save the script - RStudio does not 'save' files on creation.
6. Run the script using the **Source** button. Alternatively, highlight the
script and use the **Run** button to run the highlighted code.
7. Wrap the last line in a ```print()``` function to output the value of 
```distance_m``` to the console.

#### Exercise: Improved Accuracy

The value of the ```k_m_ratio``` used above is rounded to the second decimal
place. A more accurate conversion can be achieved by including more decimal
places. The ratio out to 6 decimal places is 0.621371. Try the following:

1. Update the value of ```k_m_ratio``` to a different decimal place.
2. Add new lines of code to complete a round trip conversion from miles
back to kilometers.
3. Convert the result of the round trip conversion to meters.

Be sure to save your script often!

## Working with Data

The dataset we are using for this tutorial consists of baby names as
registered with the US Social Security Administration. 

> Social Security Administration (2022). "Baby Names from Social Security 
Card Applications - National Data." Accessed from <https://catalog.data.gov/dataset/baby-names-from-social-security-card-applications-national-data>

The data have been modified to add column names, which are not included in
the source data. Data from 2010-2021 have been included in the full dataset
on GutHub, with file for each year. For the first part of this tutorial we 
will only used data from 2010 and 2011.

The dataset can be accessed different ways. Here we demonstrate how to
download the file directly to the project directory that we created above.

Note that the URL can be copied and pasted from the shared notes document.

```{r download data files}
file_url <- 'https://raw.githubusercontent.com/unmrds/cc-R-RStudio/master/cc-R-Names/data/2010'
download.file(file_url, './data/2010')
```

#### Exercise: Got Data?

Let's confirm that we all have the data in a place where we can use the same
path in our scripts to read the data files.

The output of the following command should be 

> [1] "2010"

Please let us know if you get a different output.

```{r check_data}
list.files("./data/")
```
### R Packages

One of the strengths of R is the large community of users and the number of 
community-developed packages that add functionality to the base environment.

For our analysis of baby names, we're going to use some of the more popular
packages for data science and visualization. If we're using R and RStudio for
the first time, it's likely that these packages will need to be installed.

We will install 3 packages:

* readr
* dplyr
* ggplot2

If you have previously installed the *tidyverse,* then you already have these
packages. 

We can install, verify, and load packages in the **Packages** tab in the 
lower right pane of RStudio. We can also use the following commands - note 
however that the ```install.packages``` command should be run in the console 
and not included in scripts.

```{r install_packages, eval=FALSE, include=FALSE}
install.packages('readr')
install.packages('dplyr')
install.packages('ggplot2')
```
It may take a moment for the packages to install. If you have not already 
installed the tidyverse, we do recommend doing that sometime after this
workshop. However, it's a large meta-package that can take a while to install,
so we prefer to work with the individual packages during workshops.

Once we have installed packages, we need to load them into our environment.
This is something we definitely want to include in our scripts. Let's create a
new blank script file and save it in our working directory as 'baby_names.R.'

Add these lines:

```{r load_packages}
library(readr)
library(dplyr)
library(ggplot2)
```

After running these lines, we can confirm that they have been loaded into
the environment using the ```search()``` function.

```{r confirm_packages}
search()
```

Admittedly, we have spent a good bit of our time so far setting up and
double-checking our environment. We recommend making this a part of your
regular workflow - being explicit and careful about documenting paths within
your environment and packages used in an analysis is a key aspect of
developing reusable, reproducible workflows.

But now if everything is working, we're ready to have fun looking at
baby names!

### Reading Files

The first thing we need to do is read our data into memory. There are two
commonly used functions for reading CSV data in R - ```read.csv()```, which
is part of the standard library, and ```read_csv()```, which comes with the 
```readr``` package we installed earlier. We're going to use the latter.

```{r read_csv}
names2010 <- read_csv("./data/2010")
```

Note that we have created an object, *names2010*, and stored the data as the
value of that object. The **Environment** tab provides some information
about the object. We can also inspect it using various commands.

```{r inspect_data}
# View the data as a table in the file pane
View(names2010)

# View the data in the console
names2010

# Get information about the structure of the data
# This is a good sanity check to confirm data types are correct,
# so we will take a moment to review the output.
str(names2010)
```

### Inspect the Data

In addition to inspecting our data, we can use various methods to get 
information.

```{r explore_data}
# Get the size of the data
dim(names2010)

# Get column names
names(names2010)

# Syntax for selecting a column
# names2010$name

# Get the count of babies with the most popular name overall.
# Note this doesn't include the name itself.

# We can get the name and other aggregations using base R methods
# but for now we will pass on that and just get the maximum of the count field. 
# In a minute we will introduce dplyr, which offers similar functionality
# but allows us to develop more human readable workflows.
max(names2010$count)
```

*Slicing* or subsetting data in R using conditions and index positions of
rows and columns is an important topic. We can point to resources that go
into how R indexes dataframes in more detail.

That said, there is a more accessible and human readable way to subset 
dataframes using the ```dplyr``` library. Today we are going to focus on that.

But first, we looked above at how to get the maximum value within a column. We
can use the ```summary()``` function to view descriptive statistics for a
dataframe.

```{r desc_stats}
# For all columns
summary(names2010)

# For a single columns
summary(names2010$count)
```
Something to note here is that the 'sex' column is being treated as
continuous data, whereas it is really categorical data.  Let's see 
how the descriptive statistics change if we tell R to treat 'sex' as a
factor (categorical data).

```{r factor_sex}
names2010$sex <- as.factor(names2010$sex)
str(names2010$sex)
```

Comparing the output of our summary function with the previous output,
we see that the descriptive statistics now include a count of rows by
category.

```{r desc_factor}
summary(names2010)
```
Converting 'sex' to a factor also makes it possible to plot that variable. R's
powerful plotting capabilities are one reason for its popularity.

```{r plot_sex}
plot(names2010$sex)
```

#### Exercise: On Your Own

Let's take a moment to go back over some of the things we've done. Using the
commands we've already looked at:

1. Read the 2011 baby name data into an object. Name the object *names2011*. 
The url for the 2011 data is https://raw.githubusercontent.com/unmrds/cc-R-RStudio/master/cc-R-Names/data/2011
2. Identify the most popular name overall in the dataset.
3. Change the 'sex' column to a factor and generate descriptive statistics 
showing the total count of babies with SSN registrations by sex.
4. Plot the distribution of babies by sex.

```{r solution_a}
file_url <-  'https://raw.githubusercontent.com/unmrds/cc-R-RStudio/master/cc-R-Names/data/2011'
download.file(file_url, './data/2011')
names2011 <- read_csv("./data/2011")
names2011[which.max(names2011$count), 1]
names2011$sex <- as.factor(names2011$sex)
summary(names2011)
plot(names2011$sex)
```

## Manipultaing Data with ```dplyr```

```{r intro_dplyr}
# Another way to get the most popular baby name
# introducing a new operator - the margittr pipe: %>%
# CTL+SHIFT+M
# explain what is a pipe - output of one command as input to another
names2011 %>% 
  filter(count == max(count))

# That is longer than the base R syntax for pulling this same data point
# but is much easier to read
# and we can add more conditions - in both years so far the most popular
# name has been a girl's name. What is the most popular boy's name?
names2011 %>%
  filter(sex == "M") %>% 
  filter(count == max(count))
```

#### Exercise

Daisy-chaining pipes versus using multiple conditions.

```{r order_pipes}
# Why does this work:
names2011 %>% 
  filter(sex == "F" & count == max(count))

# But this doesn't?
# Note - it is 'working' in that it doesn't throw an error
# but there is no row that satisfies both conditions
# because the max count value in the dataset is for a girl name
names2011 %>% 
  filter(sex == "M" & count == max(count))
```


Get the most popular name for both sexes.

```{r both_popular}
names2011 %>% 
  group_by(sex) %>% 
  summarise(popular_name = name[which.max(count)], # note we select a 
            count = max(count))

names2010 %>% 
  group_by(sex) %>% 
  summarise(popular_name = name[which.max(count)], # note we select a 
            count = max(count))
```

Filter, group by, and summarise are three common dplyr methods. Two more are
select and mutate.

```{r dplyr_methods}
names2010 %>%
  select(name, count)

names2010 %>% 
  select(name) %>% 
  # Let's say for some reason we wanted to uppercase the name
  mutate(uppercase = toupper(name))
```


**Order of methods matters!**

### Combine Dataframes

The most popular girl's name changed between 2010 and 2011. The most popular
boy's name was the same, but what are the most popular names across the two
years?


```{r merge}
# FIRST! Notice our data do not have a column for the year - that
# data is only included in the filename.
# Let's add a column for the year before merging
names2010$year <- '2010'
names2011$year <- '2011'

# There are a couple ways to do this
long_names <- rbind(names2010, names2011)
str(long_names)

# Using dplyr bind_rows
long_names_2 <- names2010 %>% 
  bind_rows(names2011)
str(long_names_2)
```

Many if not most names will now probably occur twice:

```{r count_sophia}
long_names %>% 
  filter(name == 'Sophia')

# Did not expect that!
# We can show that this is in the raw data...
# but Sophia is not a popular boy's name so we will filter for that
long_names %>% 
  filter(name == "Sophia" & sex == "F")

# So now we need to start aggregating the data.
# Split (group), apply (calculate), combine (aggregate)
```
```{r split_apply}
# Let's create an object to hold the aggregate data
name_trends <- long_names %>% 
  group_by(name, sex) %>% 
  mutate(total = sum(count)) %>% 
  filter(sex == "F") %>% 
  select(name, sex, total) %>% 
  head(5) # top 5 names
name_trends
```

A different way to get the same result:

```{r sac_2}
name_trends <- 
  long_names %>% 
  group_by(name, sex) %>% 
  filter(sex == "F") %>% 
  summarise(total = sum(count)) %>% 
  arrange(desc(total)) %>% 
  head(5)
name_trends
```

The former approach allows us to more easily get the most popular name for
both boys and girls.

```{r both_pop}
most_popular <- long_names %>% 
  group_by(name, sex) %>% 
  mutate(total = sum(count)) %>% 
  select(name, sex, total) %>% 
  # We can regroup our subset!
  group_by(sex) %>% 
  summarise(popular_name = name[which.max(total)], t = max(total))
most_popular
```


#### Exercise: The Winner Is...

Before we can proceed with the next exercise, we need to download the rest of
the data. We could use the same process as above, but since there are several
files (through 2021) it makes sense to download the zip file of all the data
from the repository for this workshop. Then we can extract is all to our *data*
directory.

Before proceeding, be sure to check that all of the data are in the right
place.

```{r check contents of data directory}
list.files('./data/')
```

Combine the data from years 2012-2015 to the 'long_names' dataframe. What
are the most popular girl's and boy's names for the timeframe 2010-2015?

```{r solution}
names2012 = read_csv("./data/2012")
names2012$year <- '2012'

names2013 = read_csv("./data/2013") 
names2013$year <- '2013'

names2014 = read_csv("./data/2014")
names2014$year <-  '2014'

names2015 = read_csv("./data/2015")
names2015$year <- '2015'

six_years = rbind(long_names, names2012, names2013, names2014, names2015)
str(six_years)
```

```{r both_pop2}
most_popular <- six_years %>% 
  group_by(name, sex) %>% 
  mutate(total = sum(count)) %>% 
  select(name, sex, total) %>% 
  # We can regroup our subset!
  group_by(sex) %>% 
  summarise(popular_name = name[which.max(total)], t = max(total))
most_popular
```

#### Exercise: How common is your name?

Using dplyr, calculate the following:

1. How many babies in the dataset have your name?
2. Extra challenge: What is the rank of your name? The proportion of babies with
your name?

```{r s1}
my_name <- six_years %>% 
  group_by(name) %>% 
  filter(name == "Jonathan") %>% 
  summarise(num_babies = sum(count))
my_name
```

```{r s2}
boys <- six_years %>% 
  filter(sex == "M")
gt <- sum(boys$count)
rank_name <- boys %>%
  group_by(name) %>% 
  summarise(total = sum(count)) %>% 
  arrange(desc(total)) %>% 
  mutate(rank = 1:n(), proportion = round((total/gt)*100, 3)) %>% # from 1 to n()
  filter(name == "Jonathan")
rank_name
```


### Plotting

We now have a pretty large dataset with annual baby name data. We've manipulated
the data to tease out data points and aggregations.

Plotting allows us to visualize trends. For example, we know Sophia and Isabella
are popular girl's names. We can plot their relative popularity.

```{r plot}
# First, create a subset
sophia <- six_years %>% 
  filter(sex == "F" & name == "Sophia")
sophia

# now plot
sophia_plot <- ggplot(sophia, aes(year,count))
sophia_plot + geom_point()
```

Two names


```{r plot2}
# First, create a subset
names_compare <- six_years %>% 
  filter(sex == "F" & (name == "Sophia" | name == "Isabella"))
names_compare

# now plot
names_plot <- ggplot(names_compare, aes(year,count))
names_plot + geom_point(aes(color=name))
```

```{r plot3}
# First, create a subset
names_compare <- six_years %>% 
  filter(sex == "F" & (name == "Sophia" | name == "Isabella"))
names_compare

# now plot
names_plot <- ggplot(names_compare, aes(year, count, group=name))
names_plot + geom_line(aes(color=name)) + geom_point(aes(color=name))
```


```{r plot4}
# First, create a subset
names_compare <- six_years %>% 
  filter(sex == "F" & (name == "Sophia" | name == "Isabella"))
names_compare

# now plot
names_plot <- ggplot(names_compare, aes(year, count, group=name))
names_plot + geom_line(aes(color=name)) + geom_point(aes(color=name)) +
  labs(x = "Year", y = "Count", title = "Name Comparison: Sophia and Isabella")
```


```{r plot5}
# First, create a subset
names_compare <- six_years %>% 
  filter(sex == "F" & (name == "Sophia" | name == "Isabella"))
names_compare

# now plot
# other themes: light, minimal, classic
names_plot <- ggplot(names_compare, aes(year, count, group=name))
names_plot + geom_line(aes(color=name)) + geom_point(aes(color=name)) +
  labs(x = "Year", y = "Count", title = "Name Comparison: Sophia and Isabella") +
  theme_light()
```


### Exericse: Your name plot

Plot the trend in your name against another name.

How would we include even more names?

```{r plot6}
# First, create a subset
names_compare <- six_years %>% 
  filter(sex == "M" & (name == "Jacob" | name == "Jonathan" | name == "Todd"))
names_compare

# now plot
# other themes: light, minimal, classic
names_plot <- ggplot(names_compare, aes(year, count, group=name))
names_plot + geom_line(aes(color=name)) + geom_point(aes(color=name)) +
  labs(x = "Year", y = "Count", title = "Name Comparison: Sophia and Isabella") +
  theme_light()
```
















